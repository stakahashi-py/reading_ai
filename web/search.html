<!doctype html>
<html lang="ja">

<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
  <title>MasterpIece - 探す</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <link rel="stylesheet" href="/web/styles.css" />
  <link rel="icon" href="/web/favicon.ico">
  <script>
    tailwind.config = {
      theme: {
        extend: {
          colors: { accent: '#93c5fd' } // パステルブルー
        }
      }
    }
  </script>
  <!-- Firebase Auth（最小） -->
  <script src="https://www.gstatic.com/firebasejs/10.13.1/firebase-app-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/10.13.1/firebase-auth-compat.js"></script>
  <script src="/web/auth.js"></script>
  <!-- Markdown renderer（将来の応答整形用）。QA画面で主に使用。ここでは読み込むだけ。 -->
  <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/dompurify@3.0.9/dist/purify.min.js"></script>
  <style>
    body {
      font-family: system-ui, -apple-system, Segoe UI, Roboto, sans-serif;
    }
  </style>
  <script>
    function qs(name) { const p = new URLSearchParams(location.search); return p.get(name); }
    function setQS(params) { const p = new URLSearchParams(params); history.replaceState(null, '', `?${p.toString()}`); }

    let sOffset = 0; const sLimit = 10; let lastBody = null; let loading = false; let total = 0;
    const bookProgress = new Map();

    async function search() {
      const q = document.getElementById('q').value.trim();
      const author = document.getElementById('author').value.trim();
      const era = document.getElementById('era').value;
      setQS({ q, author, era });
      const body = { query: q };
      if (author) body.author = author;
      if (era) body.era = era;
      document.getElementById('results').innerHTML = '検索中…';
      sOffset = 0; lastBody = body; await loadMore();
    }

    async function loadMore() {
      if (loading) return; loading = true;
      const res = await fetch('/v1/search/title', { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ ...lastBody, offset: sOffset, limit: sLimit }) });
      const data = await res.json();
      total = data.total || 0;
      renderResults(data.items || [], sOffset === 0);
      sOffset += (data.items || []).length;
      loading = false;
      renderLoadMore();
    }

    function renderLoadMore() {
      const box = document.getElementById('more');
      box.innerHTML = '';
      if (sOffset < total) {
        const btn = document.createElement('button');
        btn.textContent = 'もっと見る';
        btn.className = 'px-4 py-2 rounded-lg border border-gray-200 hover:bg-gray-50';
        btn.onclick = loadMore;
        box.appendChild(btn);
      }
    }

    function statusFromProgress(p) {
      if (!p) return { label: '未読', sort: 2 };
      if (p.completed_at) return { label: '読了', sort: 1 };
      const pct = typeof p.scroll_percent === 'number' ? p.scroll_percent : parseFloat(p.scroll_percent) || 0;
      if (pct >= 1) return { label: '読書中', sort: 0 };
      return { label: '未読', sort: 2 };
    }

    function badgeClass(label) {
      switch (label) {
        case '読了':
          return 'bg-emerald-100 text-emerald-800 border border-emerald-200';
        case '読書中':
          return 'bg-amber-100 text-amber-800 border border-amber-200';
        default:
          return 'bg-gray-100 text-gray-700 border border-gray-200';
      }
    }

    async function fetchProgressFor(items) {
      const ids = items.map(it => it.id).filter((v, i, a) => a.indexOf(v) === i);
      if (!ids.length) return;
      try {
        const res = await fetch('/v1/progress/list', { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ book_ids: ids }) });
        const data = await res.json();
        for (const it of (data.items || [])) bookProgress.set(it.book_id, it);
      } catch (e) { }
    }

    async function renderResults(items, reset) {
      const box = document.getElementById('results');
      if (reset) box.innerHTML = '';
      if (!items.length) { box.textContent = '該当なし'; return; }
      await fetchProgressFor(items);
      const groups = { reading: [], completed: [], unread: [] };
      for (const it of items) {
        const el = document.createElement('div');
        const subtitle = [it.author, it.era].filter(Boolean).join(' / ');
        const prog = bookProgress.get(it.id);
        const st = statusFromProgress(prog);
        el.className = 'border border-gray-100 rounded-xl shadow-sm p-4 mt-3';
        const badge = badgeClass(st.label);
        el.innerHTML = `
          <div class="flex items-start justify-between gap-3">
            <div>
              <div class="font-semibold">${it.title || 'Untitled'}</div>
              <div class="text-gray-500 text-sm">${subtitle}</div>
              ${it.snippet ? `<div class="mt-2">${it.snippet.replaceAll('\n', ' ')}</div>` : ''}
            </div>
            <div class="md:text-right md:min-w-[140px]">
              ${typeof it.score === 'number' ? `<div class="text-gray-400 text-xs">score: ${it.score.toFixed(3)}</div>` : ''}
              <div class="mt-1 text-xs hidden md:block"><span class="inline-block px-2 py-0.5 rounded ${badge}">${st.label}</span></div>
              <div class="mt-1 flex gap-2 items-center md:justify-end">
                <span class="inline-block px-2 py-0.5 rounded ${badge} text-xs md:hidden">${st.label}</span>
                ${st.label === '読了' ? `<button class=\"hidden sm:inline-flex items-center h-8 px-3 rounded border border-gray-300 text-sm\" onclick=\"openReviewModal(${it.id})\">感想表示</button>` : ''}
                <a class="inline-flex items-center h-8 px-3 rounded bg-sky-500 text-white text-sm" href="/web/read.html?book_id=${it.id}">読む</a>
              </div>
            </div>
          </div>
        `;
        if (st.label === '読書中') groups.reading.push(el);
        else if (st.label === '読了') groups.completed.push(el);
        else groups.unread.push(el);
      }
      for (const el of [...groups.reading, ...groups.completed, ...groups.unread]) box.appendChild(el);
    }

    function restoreFromQS() {
      const q = qs('q') || '';
      const author = qs('author') || '';
      const era = qs('era') || '';
      document.getElementById('q').value = q;
      document.getElementById('author').value = author;
      if (era) document.getElementById('era').value = era;
      if (q || author || era) search();
    }

    function onKey(e) { if (e.key === 'Enter') { e.preventDefault(); search(); } }

    async function loadFilters() {
      const selEra = document.getElementById('era');
      const ERAS = ["明治", "大正", "昭和", "不明"]; // 固定プリセット
      for (const e of ERAS) {
        const opt = document.createElement('option');
        opt.value = e; opt.textContent = e; selEra.appendChild(opt);
      }
    }

    // 初期表示：未検索なら 読書中→読了→未読 の順に並べる
    async function loadInitialRanking() {
      const res = await fetch('/v1/books?offset=0&limit=200');
      const data = await res.json();
      const items = data.items || [];
      // 進捗を一括取得
      await fetchProgressFor(items);
      const withStatus = items.map(b => ({
        b, st: (function (p) {
          if (!p) return { key: 2, t: 0 };
          if (p.completed_at) return { key: 1, t: new Date(p.completed_at).getTime() };
          return { key: 0, t: new Date(p.updated_at || 0).getTime() };
        })(bookProgress.get(b.id))
      }));
      withStatus.sort((x, y) => x.st.key - y.st.key || y.st.t - x.st.t);
      await renderResults(withStatus.map(x => x.b), true);
    }

    // 右カラム：チャット（基本メッセージバブル）
    function appendChat(role, html) {
      const box = document.getElementById('chat-log');
      const wrap = document.createElement('div');
      wrap.className = `flex ${role === 'user' ? 'justify-end' : 'justify-start'} my-2`;
      const bubble = document.createElement('div');
      bubble.className = `max-w-[92%] sm:max-w-[80%] rounded-2xl px-3 py-2 text-sm ${role === 'user' ? 'bg-sky-500 text-white' : 'bg-gray-100 text-gray-800'}`;
      bubble.innerHTML = html;
      wrap.appendChild(bubble);
      box.appendChild(wrap);
      box.scrollTop = box.scrollHeight;
    }

    // --- Librarian Agent 連携（SSE） ---
    const AGENT_BASE = 'https://librarian-agent-858293481093.us-central1.run.app';
    let USER_ID = null; // Firebaseのuidを使用
    const SESSION_ID = 'session';
    let chatBooted = false; // 初チャット判定

    function createStreamArea() {
      // 1つの応答に対して、イベント順に要素を積むコンテナ
      const box = document.getElementById('chat-log');
      const wrap = document.createElement('div');
      wrap.className = 'flex justify-start my-2';
      const col = document.createElement('div');
      col.className = 'max-w-[92%] sm:max-w-[80%] flex flex-col gap-2';
      wrap.appendChild(col);
      box.appendChild(wrap);
      box.scrollTop = box.scrollHeight;

      let statusEl = null;
      let textBubble = null;
      let buffer = '';
      let lastIncoming = '';

      const addStatus = (text) => {
        if (!statusEl) {
          statusEl = document.createElement('div');
          statusEl.className = 'rounded-2xl px-3 py-2 text-xs bg-gray-50 text-gray-600 border border-gray-200';
          col.appendChild(statusEl);
        }
        statusEl.textContent = text;
        box.scrollTop = box.scrollHeight;
      };
      const removeStatus = () => {
        if (statusEl && statusEl.parentNode) statusEl.parentNode.removeChild(statusEl);
        statusEl = null;
      };

      const stylizeLinks = (container) => {
        const as = container.querySelectorAll('a');
        as.forEach(a => {
          const href = a.getAttribute('href') || '';
          if (/^\d+$/.test(href)) {
            a.setAttribute('href', `/web/read.html?book_id=${href}`);
          }
          a.setAttribute('target', '_blank');
          a.setAttribute('rel', 'noopener noreferrer');
          a.classList.add('text-sky-600', 'underline', 'hover:text-sky-700');
        });
      };

      const appendText = (incoming) => {
        // 進行状態のバブルは削除
        removeStatus();
        if (!incoming) return;
        // 重複/累積送信の吸収
        let chunk = incoming;
        if (lastIncoming && incoming.startsWith(lastIncoming)) {
          chunk = incoming.slice(lastIncoming.length);
          lastIncoming = incoming;
        } else if (lastIncoming && (lastIncoming.endsWith(incoming) || incoming === lastIncoming)) {
          // 同一または一部重複 → 追記不要
          lastIncoming = incoming;
          return;
        } else {
          lastIncoming += incoming;
        }
        buffer += chunk;

        // レイジー生成
        if (!textBubble) {
          textBubble = document.createElement('div');
          textBubble.className = 'rounded-2xl px-3 py-2 text-sm bg-gray-100 text-gray-800';
          col.appendChild(textBubble);
        }

        // テキストノードを安全に積む（<a ...>...</a> だけ特別扱い）
        const flushText = (text) => {
          if (!text) return;
          const parts = text.split(/\n/);
          for (let i = 0; i < parts.length; i++) {
            if (parts[i]) textBubble.appendChild(document.createTextNode(parts[i]));
            if (i < parts.length - 1) textBubble.appendChild(document.createElement('br'));
          }
        };

        const makeAnchor = (href, label) => {
          const a = document.createElement('a');
          const isNum = /^\d+$/.test(href || '');
          a.href = isNum ? `/web/read.html?book_id=${href}` : href || '#';
          a.target = '_blank';
          a.rel = 'noopener noreferrer';
          a.className = 'text-sky-600 underline hover:text-sky-700';
          a.textContent = label || href || '';
          return a;
        };

        while (buffer.length) {
          const i = buffer.indexOf('<a ');
          if (i === -1) {
            // アンカーが無い → 全てテキストとして出力
            flushText(buffer);
            buffer = '';
            break;
          }
          // 先頭のテキスト部分を出力
          if (i > 0) {
            flushText(buffer.slice(0, i));
            buffer = buffer.slice(i);
          }
          // ここから <a ...> を解析
          const closeTag = buffer.indexOf('</a>');
          const gt = buffer.indexOf('>');
          if (gt === -1 || closeTag === -1 || gt > closeTag) {
            // 閉じタグまたは '>' がまだ来ていない → さらに受信を待つ
            break;
          }
          const openTag = buffer.slice(0, gt + 1); // 例: <a href="123">
          const inner = buffer.slice(gt + 1, closeTag); // 例: タイトル
          const rest = buffer.slice(closeTag + 4);

          // href抽出
          const m = openTag.match(/href\s*=\s*\"([^\"]*)\"/i);
          const href = m ? m[1] : '';
          // アンカー要素を追加
          textBubble.appendChild(makeAnchor(href, inner));

          buffer = rest;
        }

        box.scrollTop = box.scrollHeight;
      };

      const appendFunctionCall = (name) => {
        const el = document.createElement('div');
        el.className = 'rounded-xl px-3 py-2 text-xs bg-amber-50 text-amber-900 border border-amber-200';
        el.textContent = `関数呼び出し中 -${name}-`;
        col.appendChild(el);
        // 次のテキストは新規バブルにする
        textBubble = null;
        buffer = '';
        lastIncoming = '';
        box.scrollTop = box.scrollHeight;
      };

      return { addStatus, removeStatus, appendText, appendFunctionCall };
    }

    function rewriteLinksForReader(html) { return html; }

    async function initAgentSession() {
      // プリフライト回避のため自サーバ経由で初期化
      await fetch(`/v1/librarian/session/init?user_id=${encodeURIComponent(USER_ID)}`, { method: 'POST' });
    }

    async function buildReadingBackground() {
      // FastAPIから 読了本+感想、ハイライトを取得し所定フォーマットへ
      try {
        const [progRes, hlAllRes] = await Promise.all([
          fetch('/v1/progress/list', { method: 'POST', body: JSON.stringify({}) }),
          fetch('/v1/highlights'),
        ]);
        const progData = await progRes.json();
        const hlAll = await hlAllRes.json();
        const completed = (progData.items || []).filter(it => !!it.completed_at);
        const bookIds = [...new Set(completed.map(it => it.book_id))];
        const books = await Promise.all(bookIds.map(async id => {
          const r = await fetch(`/v1/books/${id}`);
          const d = await r.json();
          return d && d.id ? d : { id };
        }));
        const feedbacks = await Promise.all(bookIds.map(async id => {
          const r = await fetch(`/v1/feedback?book_id=${id}`);
          const d = await r.json();
          return { id, text: (d && d.item && d.item.text) || '' };
        }));
        const fbById = Object.fromEntries(feedbacks.map(f => [f.id, f.text]));
        const bookById = Object.fromEntries(books.map(b => [b.id, b]));
        const hlByBook = {};
        for (const h of (hlAll.items || [])) {
          if (!hlByBook[h.book_id]) hlByBook[h.book_id] = [];
          hlByBook[h.book_id].push(h.text_snippet);
        }

        const lines = [];
        lines.push('# ユーザーの読書履歴');
        lines.push('## 読了済みの本');
        for (const id of bookIds) {
          const b = bookById[id] || { title: '不明', author: '' };
          const title = b.title || '不明';
          const author = b.author || '';
          const fb = (fbById[id] || '').trim();
          lines.push(`### ${title} ${author}`.trim());
          lines.push(`感想: ${fb || '（未記入）'}`);
        }
        lines.push('## ハイライトした文章');
        for (const id of bookIds) {
          const b = bookById[id] || { title: '不明', author: '' };
          const title = b.title || '不明';
          const author = b.author || '';
          const hs = hlByBook[id] || [];
          if (!hs.length) continue;
          lines.push(`### ${title} ${author}`.trim());
          for (const t of hs) lines.push(`> ${t}`);
        }
        return lines.join('\n');
      } catch (e) {
        // 失敗時は空の背景にする
        return '# ユーザーの読書履歴\n(取得に失敗しました)';
      }
    }

    async function postSSEAndStream({ userInput, backgroundIfFirst, streamUI }) {
      const controller = new AbortController();

      const payload = chatBooted ? {
        app_name: 'librarian_agent',
        user_id: USER_ID,
        session_id: SESSION_ID,
        new_message: { role: 'user', parts: [{ text: userInput }] },
        streaming: true,
      } : {
        app_name: 'librarian_agent',
        user_id: USER_ID,
        session_id: SESSION_ID,
        new_message: { role: 'user', parts: [{ text: `${backgroundIfFirst}\n# ユーザーの質問\n${userInput}` }] },
        streaming: true,
      };

      let receivedAny = false;
      try {
        // 自サーバのプロキシにPOST → 外部SSEを中継
        const res = await fetch(`/v1/librarian/run_sse`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json', 'Accept': 'text/event-stream' },
          body: JSON.stringify(payload),
          signal: controller.signal,
        });
        if (!res.ok || !res.body) throw new Error(`HTTP ${res.status}`);

        const reader = res.body.getReader();
        const decoder = new TextDecoder('utf-8');
        let buffer = '';
        while (true) {
          const { value, done } = await reader.read();
          if (done) break;
          buffer += decoder.decode(value, { stream: true });
          // SSEは\n\nで区切られる想定
          const parts = buffer.split(/\n\n/);
          buffer = parts.pop() || '';
          for (const evt of parts) {
            // data: ... 行のみ抽出
            const m = evt.split('\n').filter(l => l.startsWith('data:'))
              .map(l => l.replace(/^data:\s?/, '')).join('');
            if (!m) continue;
            let json;
            try { json = JSON.parse(m); } catch (_) { continue; }
            const part = json && json.content && json.content.parts && json.content.parts[0] || {};
            if (part.text && json.partial) {
              receivedAny = true;
              const html = rewriteLinksForReader(part.text);
              streamUI.appendText(html);
            } else if (part.functionCall) {
              streamUI.appendFunctionCall(part.functionCall.name);
            }
            // スクロール追従
            const box = document.getElementById('chat-log');
            box.scrollTop = box.scrollHeight;
          }
        }
      } catch (e) {
        streamUI.removeStatus();
        const errUI = createStreamArea();
        errUI.appendText(`ストリーミングに失敗しました: ${e && e.message ? e.message : e}`);
      } finally {
        chatBooted = true;
        // 応答が全く無い場合はステータスのみ置換
        if (!receivedAny) streamUI.addStatus('応答がありませんでした。');
      }
    }

    // 感想モーダル
    async function openReviewModal(bookId) {
      const dlg = document.getElementById('review-modal');
      const ta = document.getElementById('review-text');
      const saveBtn = document.getElementById('review-save');
      ta.value = '';
      let existingId = null;
      try {
        const r = await fetch(`/v1/feedback?book_id=${bookId}`);
        const d = await r.json();
        if (d.item) { ta.value = d.item.text || ''; existingId = d.item.id; }
      } catch (e) { }
      saveBtn.onclick = async () => {
        const text = ta.value;
        if (existingId) { await fetch(`/v1/feedback/${existingId}`, { method: 'PUT', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ text }) }); }
        else { await fetch('/v1/feedback', { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ book_id: bookId, text }) }); }
        dlg.close();
      };
      dlg.showModal();
    }
    function setTyping(on) {
      const t = document.getElementById('chat-typing');
      if (!t) return;
      t.classList.toggle('hidden', !on);
    }
    let chatBusy = false;
    function setSendBusy(busy) {
      const btn = document.getElementById('chat-send');
      if (!btn) return; btn.disabled = busy;
      btn.classList.toggle('bg-sky-500', !busy);
      btn.classList.toggle('bg-gray-400', busy);
      btn.classList.toggle('cursor-not-allowed', busy);
      btn.classList.toggle('opacity-70', busy);
    }
    async function sendChat() {
      if (chatBusy) return;
      const inp = document.getElementById('chat-input');
      const q = inp.value.trim(); if (!q) return;
      appendChat('user', q.replaceAll('\n', '<br/>'));
      inp.value = '';

      chatBusy = true; setSendBusy(true); if (inp) inp.disabled = true;
      try {
        // 初回のみ：セッション初期化＋背景構築
        let background = '';
        if (!chatBooted) {
          // Firebaseのuidを取得
          try {
            const u = (window.firebase && window.firebaseReady) ? await window.firebaseReady : null;
            USER_ID = u && u.uid ? u.uid : 'anonymous';
          } catch (_) { USER_ID = 'anonymous'; }
          // この応答のUI領域
          const streamUI = createStreamArea();
          streamUI.addStatus('情報収集中...');
          await initAgentSession();
          background = await buildReadingBackground();
          // 情報収集完了 → ストリーミングの待機表示へ
          streamUI.addStatus('考え中...');
          await postSSEAndStream({ userInput: q, backgroundIfFirst: background, streamUI });
          return;
        }
        // 2回目以降：直接ストリーミング（考え中...表示）
        const streamUI = createStreamArea();
        streamUI.addStatus('考え中...');
        await postSSEAndStream({ userInput: q, backgroundIfFirst: background, streamUI });
      } finally {
        chatBusy = false; setSendBusy(false); if (inp) inp.disabled = false; inp.focus();
      }
    }

    window.addEventListener('DOMContentLoaded', async () => {
      // モバイルではチャットを検索フォーム直下へ移動
      function relocateChatForSearch() {
        const chatCol = document.getElementById('chat-col');
        const chatPanel = document.getElementById('chat-panel');
        const grid = document.getElementById('grid-root');
        const mobileAnchor = document.getElementById('chat-mobile-anchor');
        const isLg = window.matchMedia('(min-width: 1024px)').matches;
        if (!chatCol || !chatPanel || !grid || !mobileAnchor) return;
        if (isLg) {
          // デスクトップ：元の位置（グリッド直下の右カラム）へ戻す＋sticky高さ
          if (chatCol.parentElement !== grid) grid.appendChild(chatCol);
          chatPanel.classList.add('sticky', 'h-chat');
          chatPanel.style.top = '64px';
        } else {
          // モバイル：検索フォーム直下へ移動、sticky解除して高さは自動
          if (chatCol.parentElement !== mobileAnchor) mobileAnchor.after(chatCol);
          chatPanel.classList.remove('sticky', 'h-chat');
          chatPanel.style.top = '';
        }
      }
      relocateChatForSearch();
      window.matchMedia('(min-width: 1024px)').addEventListener('change', relocateChatForSearch);

      await loadFilters();
      const q = qs('q') || '' || qs('author') || qs('era');
      restoreFromQS();
      if (!(qs('q') || qs('author') || qs('era'))) {
        // 未検索状態
        document.getElementById('results').innerHTML = '読み込み中…';
        await loadInitialRanking();
      }
      // 初期メッセージ
      appendChat('assistant', 'おかえりなさい！今日はどんな本を読みますか？');
    });
  </script>
</head>

<body>
  <header
    class="sticky top-0 z-20 bg-white/90 backdrop-blur h-14 border-b border-gray-100 shadow-sm px-4 flex items-center gap-3"
    style="--header-h: 56px;">
    <div class="flex items-center gap-2">
      <img src="/web/logo.png" alt="MasterpIece" class="h-10 w-auto select-none" />
    </div>
    <div class="ml-auto flex items-center gap-2">
      <a href="/web/gallery.html"
        class="inline-flex items-center h-9 px-3 rounded-lg bg-sky-500 text-white text-sm hover:bg-sky-600 transition">
        ギャラリー
      </a>
    </div>
  </header>
  <main class="container mx-auto max-w-screen-xl">
    <div id="grid-root" class="p-4 grid grid-cols-10 gap-4">
      <!-- 左：通常検索（6） -->
      <div id="left-col-search" class="col-span-10 lg:col-span-6">
        <div class="flex flex-wrap gap-x-2 gap-y-2" role="search" aria-label="本の検索">
          <input id="q" aria-label="タイトル" placeholder="タイトル（完全一致/部分一致）"
            class="w-full sm:flex-1 min-w-0 border border-gray-200 rounded-lg px-3 h-10 focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-sky-300"
            onkeydown="onKey(event)" />
          <input id="author" aria-label="作者" placeholder="作者（部分一致）"
            class="w-full sm:w-48 border border-gray-200 rounded-lg px-3 h-10 focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-sky-300"
            onkeydown="onKey(event)" />
          <select id="era" aria-label="時代"
            class="w-full sm:w-36 border border-gray-200 rounded-lg px-3 h-10 text-[15px] focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-sky-300">
            <option value="">時代</option>
          </select>
          <button onclick="search()"
            class="w-full sm:w-auto bg-sky-500 hover:bg-sky-600 text-white rounded-lg h-10 px-4 transition">検索</button>
        </div>
        <!-- モバイル時：チャットをこの位置に差し込む -->
        <div id="chat-mobile-anchor" class="block lg:hidden mt-3"></div>
        <div id="results" class="mt-4 text-gray-600">条件を入力して検索してください。</div>
        <div id="more" class="my-4"></div>
      </div>

      <!-- 右：チャット（4） -->
      <div class="col-span-10 lg:col-span-4" id="chat-col">
        <div id="chat-panel" class="border border-gray-100 rounded-xl shadow-sm sticky h-chat"
          style="top: var(--header-h, 64px);">
          <div class="h-full flex flex-col">
            <div id="chat-log" class="flex-1 overflow-auto p-3 space-y-2" role="log" aria-live="polite"></div>
            <!-- 入力中インジケータは冗長のため削除 -->
            <div class="border-t border-gray-200 p-2 pb-safe flex gap-2">
              <input id="chat-input" placeholder="おすすめの本を教えて"
                class="flex-1 border border-gray-200 rounded-lg px-3 h-10 focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-sky-300"
                onkeydown="if(event.key==='Enter'){sendChat()}" />
              <button id="chat-send" onclick="sendChat()"
                class="bg-sky-500 hover:bg-sky-600 text-white rounded-lg h-10 px-4 transition">送信</button>
            </div>
          </div>
        </div>
      </div>
    </div>

    <dialog id="review-modal" class="rounded max-w-xl w-[90vw]">
      <div class="p-4 space-y-3 modal-body-limit">
        <div class="text-lg font-semibold">感想</div>
        <textarea id="review-text" class="w-full h-40 border border-gray-300 rounded p-2"
          placeholder="感想を入力"></textarea>
        <div class="flex justify-end gap-2">
          <button class="px-3 py-1 border border-gray-200 rounded-lg hover:bg-gray-50"
            onclick="document.getElementById('review-modal').close()">閉じる</button>
          <button id="review-save" class="px-3 py-1 bg-sky-500 hover:bg-sky-600 text-white rounded-lg">保存</button>
        </div>
      </div>
    </dialog>
  </main>
</body>

</html>
